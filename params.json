{"name":"Requirejs-glue-plugin","tagline":"An attempt to bring Dependency Injection to javascript via RequireJS","body":"[![Build Status](https://travis-ci.org/Luismahou/requirejs-glue-plugin.png)](https://travis-ci.org/Luismahou/requirejs-glue-plugin)\r\n[![Dependency Status](https://david-dm.org/luismahou/requirejs-glue-plugin.png)](https://david-dm.org/luismahou/requirejs-glue-plugin)\r\n[![devDependency Status](https://david-dm.org/luismahou/requirejs-glue-plugin/dev-status.png)](https://david-dm.org/luismahou/requirejs-glue-plugin#info=devDependencies)\r\n\r\n### Introduction\r\n\r\nAs a Java guy, one of the things that I missed more from my switch to Javascript, was [Google Guice](code.google.com/p/google-guice/).\r\n\r\n**GlueJs** is an attempt to fill that gap in combination with [RequireJS](requirejs.org).\r\n\r\n**GlueJs** is implemented as a RequireJS plugin.\r\n\r\n### Learn by example\r\n\r\nRequireJS configuration:\r\n```javascript\r\nrequirejs.config({\r\n    paths: {\r\n        glue: '/path/to/require/glue/plugin'\r\n    }\r\n});\r\n```\r\n\r\n**GlueJs** populates the ```binder```. The binder allows you to bind RequireJS paths.\r\n\r\n```javascript\r\n// Gets the binder. Note that the module name starts with '#'. The hash is used to distinguish between normal modules and GlueJS ones\r\nvar binder = require('glue!#binder');\r\n```\r\n\r\nYou can bind ```Foo``` into the singleton scope. \r\n```javascript\r\nbinder.bind('Foo').inSingleton();\r\n\r\n// Every time that require('glue!Foo') is executed, it will return the same instance\r\n```\r\n\r\nOr to an instance:\r\n```javascript\r\nvar foo = createFoo();\r\nbinder.bind('Foo').toInstance(foo);\r\n\r\n// require('glue!Foo') will return \"foo\"\r\n```\r\n\r\nYou can also annotate modules:\r\n```javascript\r\nbinder.bind('Foo').annotatedWith('red').toInstance(redFoo);\r\nbinder.bind('Foo').annotatedWith('blue').toInstance(blueFoo);\r\n\r\n// require('glue!Foo@red') will return \"redFoo\" while require('glue!Foo@blue') will return \"blueFoo\"\r\n```\r\n\r\n### Constraints\r\n\r\nModules loaded via **GlueJS** must ALWAYS return a class. The *magic* happens when you try to create an instance of the module:\r\n```javascript\r\ndefine(function(require) {\r\n    var Foo = require('glue!Foo');\r\n\r\n    var Bar = function() {\r\n        // When \"new\" is executed GlueJS determines how to instantiate \"Foo\"\r\n        var foo = new Foo();\r\n    };\r\n\r\n    return Bar;\r\n});\r\n```\r\n\r\n### Is Dependency Injection really necessary in a language like Javascript?\r\n\r\nIMHO is not as important as in Java. You can definitely write a successful app without it. Besides, RequireJS brings some similar features, for example, you can convert ```Foo``` into a singleton by simply:\r\n```javascript\r\ndefine(function(require) {\r\n    var Foo = function() {\r\n        // ...\r\n    };\r\n    var singleton = new Foo()\r\n    // require('Foo') will always return a reference to 'singleton'\r\n    return singleton;\r\n});\r\n```\r\n\r\nThe problem arises when you try to test your code. If ```Foo``` stores state, you'll need to clean it after every test to ensure that you're not leaking that state from one test to another. For example:\r\n\r\n```javascript\r\n// Counter definition\r\ndefine(function(require) {\r\n    var Counter = function() {\r\n        this.counter = 0;\r\n    };\r\n    Counter.prototype.increment = function() {\r\n        this.counter++;\r\n    };\r\n    Counter.prototype.decrement = function() {\r\n        this.counter--;\r\n    };\r\n    Counter.prototype.getCounter = function() {\r\n        return this.counter;\r\n    };\r\n\r\n    // Returning a singleton\r\n    return new Counter();\r\n});\r\n\r\n// In a test file\r\ndefine(function(require) {\r\n    var counter = require('counter');\r\n\r\n    describe('Counter', function() {\r\n        it('should increment counter by one', function() {\r\n            counter.increment();\r\n            expect(counter.getCounter()).to.equal(1);\r\n        });\r\n        it('should decrement counter by one', function() {\r\n            counter.decrement();\r\n            // It will fail, because the counter was modified in the previous test.\r\n            expect(counter.getCounter()).to.equal(-1);\r\n        });\r\n    });\r\n});\r\n```\r\n\r\nWith **GlueJS** the test would look like:\r\n```javascript\r\n// Counter definition\r\ndefine(function(require) {\r\n    var Counter = function() {\r\n        this.counter = 0;\r\n    };\r\n    Counter.prototype.increment = function() {\r\n        this.counter++;\r\n    };\r\n    Counter.prototype.decrement = function() {\r\n        this.counter--;\r\n    };\r\n    Counter.prototype.getCounter = function() {\r\n        return this.counter;\r\n    };\r\n\r\n    // Returning the class\r\n    return Counter();\r\n});\r\n\r\n// In a test file\r\ndefine(function(require) {\r\n    var binder  = require('glue!#binder');\r\n    var Counter = require('glue!Counter');\r\n\r\n    describe('Counter', function() {\r\n        beforeEach(function() {\r\n            binder.bind('Counter').inSingleton();\r\n\r\n            this.counter = new Counter();\r\n        });\r\n        afterEach(function() {\r\n            // Utility method that removes all the references to objects\r\n            // instantiated by GlueJS\r\n            binder.clearBindings();\r\n        });\r\n        it('should increment counter by one', function() {\r\n            this.counter.increment();\r\n            expect(this.counter.getCounter()).to.equal(1);\r\n        });\r\n        it('should decrement counter by one', function() {\r\n            this.counter.decrement();\r\n            // Now, this test will pass, because the singleton instance is re-instantiated from test to test.\r\n            expect(this.counter.getCounter()).to.equal(-1);\r\n        });\r\n    });\r\n});\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}